# Load the data generated by 01GenerateData.R
plot.data <- read.csv("GeneratedData/VoteDensity01.csv", header=TRUE, stringsAsFactors=FALSE)

# Add padding above/below where there was data

# On top
top.padding <- 1:23
for (i in top.padding) {
  plot.data <- cbind(0, plot.data)
}
# On bottom
bottom.padding <- 1:23
for (i in bottom.padding) {
  plot.data <- cbind(plot.data, 0)
}

# On left
zero.row <- vector(mode="integer", length=dim(plot.data)[1])

left.padding <- 1:10
for (i in left.padding) {
  plot.data <- rbind(zero.row, plot.data)
}

# On right
right.padding <- 1:10
for (i in left.padding) {
  plot.data <- rbind(plot.data, zero.row)
}


max <- max(plot.data) # Max value in the data, used for scaling
plottingHeight <- 1000 # Arbitrary number that provides the graph's height
scaleFactor <- 300 # Discovered through trial and error to keep the graph in the boundaries
gap <- plottingHeight / length(plot.data) # Space between lines

svg(filename = "./TestPlots/CanadaHigherRes.svg", pointsize=12, width=36, height=24)

# Create a blank plot
yVals <- as.vector(plot.data[[1]] / max * scaleFactor)
plot(0, 0, xlim=c(0, length(yVals)), ylim=c(0,1100), type="n", las=1, xlab=NA, ylab=NA, bty="n", axes=FALSE)

plotting.threshold <- 0.2

# x, y: the x and y coordinates of the hull points
# n: the number of points in the curve.
bezierCurve <- function(x, y, n=10)
{
  outx <- NULL
  outy <- NULL
  
  i <- 1
  for (t in seq(0, 1, length.out=n))
  {
    b <- bez(x, y, t)
    outx[i] <- b$x
    outy[i] <- b$y
    
    i <- i+1
  }
  
  return (list(x=outx, y=outy))
}

bez <- function(x, y, t)
{
  outx <- 0
  outy <- 0
  n <- length(x)-1
  for (i in 0:n)
  {
    outx <- outx + choose(n, i)*((1-t)^(n-i))*t^i*x[i+1]
    outy <- outy + choose(n, i)*((1-t)^(n-i))*t^i*y[i+1]
  }
  
  return (list(x=outx, y=outy))
}


for (i in 1:length(plot.data)) {
  # Grabs a row of data
  yVals <- as.vector(plot.data[[i]] / max * scaleFactor)
  xVals <- c(0:(length(yVals) - 1))
  
  # smoothed <- loess(yVals + plottingHeight~xVals)
  #yValsSmoothed <- sapply(yValsSmoothed, zeroNegatives)
  
  # xValsSmoothed <- c(0, 0:(length(yValsSmoothed) - 1), length(yValsSmoothed))
  # yValsSmoothed <- c(plottingHeight, yValsSmoothed + plottingHeight, plottingHeight)
  # newXVals <- seq(min(xVals),max(xVals), (max(xVals) - min(xVals))/10)
  
  polygon(bezierCurve(xVals, yVals + plottingHeight, 800), border = NA, col = "#ffffff")
  lines(bezierCurve(xVals, yVals + plottingHeight, 800), col="#cccccc", lwd=1.5)
  
  # # Plot the peaks with a darker line
  # j <- 2 # Skip padding
  # while (j <= (length(yVals) - 2)) {
  #   
  #   if ((yVals[j] - plottingHeight) > plotting.threshold | (yVals[j+1] - plottingHeight) > plotting.threshold) {
  #     segments(xVals[j], yVals[j], xVals[j+1], yVals[j+1], col="#000000", lwd=1.5)
  #   } else { } # Do nothing
  #   
  #   j <- j + 1
  #   
  # }
  
  plottingHeight <- plottingHeight - gap
}

dev.off()
